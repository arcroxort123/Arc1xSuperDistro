6/29/2024

This is to ATTEMPT to illustrate a build based off the documentation and all its assets in some way.
I am trying to make it look like it has a structure.
I am trying to make sure it has selections where necessary. 
I am trying to make sure these selections can be profiled/macro's and other pre-builds/templates. 
I am trying to make sure these depths/layers can hybrid with others as necessary.

Here is a 10-DEEP Layer. I just decided to type together IDK if it makes sense but it simulates the first couple of parse-structures too with some other buzzwords.
The TEMPLATE:

MAIN
--SUBSYSTEM
--|--MODULES
--|--|--SUBMODULES
--|--|--|--CHAPTER
--|--|--|--|--META
Count:/1-5/6-10/
--|--|--|--|--|--CHAIN
--|--|--|--|--|--|--CHUNK
--|--|--|--|--|--|--|--FLUX
--|--|--|--|--|--|--|--|--SecurityLevel
--|--|--|--|--|--|--|--|--|--ARRAY


Here is what it would look like if it was more detailed and specific to what each part does or tries to service:
The EXAMPLE: 

AUXILLIARY
--REFINERY
--|--REACTOR
--|--|--GAMESPACE
--|--|--|--DYNAMO
--|--|--|--|--MARKET
Count:/1-5/6-10/
--|--|--|--|--|--Recursory
--|--|--|--|--|--|--Factory
--|--|--|--|--|--|--|--Dynamic/Static/Random/As-IS
--|--|--|--|--|--|--|--|--(Strong)
--|--|--|--|--|--|--|--|--|--(Power)/Data/Light/Source/Heat/Waste/Water/Fuel/Crypto/(idk)


----So that's there, now we can go down through out module lists/index/registery of all things we suggest build or build together as or in some way correalate/conjugate to a more advanced thing if possible.
But let's assume we have like 1-2000 parts.
So we can be lazy and replace the words with numbers.

0:name
--1
--|--2
--|--|--3
--|--|--|--4
--|--|--|--|--5
Count:/1-5/6-10/
--|--|--|--|--|--6 or 6b
--|--|--|--|--|--|--7
--|--|--|--|--|--|--|--8a(8b)(8c)(8d)
--|--|--|--|--|--|--|--|--(9;30)
--|--|--|--|--|--|--|--|--|--10  or 11 and 12 or 13

Each module might hav a number/letter corresponsind a different name under its index. It may also be represented in a count of how many modules are at that buildpoint or something to the effect of what to use with what else or together, or to keep out of.
I don't have a code for this and I am too tired to see if it makes sense, the point is this is a lazy way to do things but maybe makes more efficient prep-work for codes to work.

So now we could have like---a major build work with other major builds and program them to work in order to their priorities under request by appearence or something.
1,13,17,3,2,299,133,120,1560,150,200:name 

And that would typically be something with many other things working as a uniform/product based of whatever it is. And whatever it makes comes out as whatever it is.
1245:product

So if you wanted 1245 and you wanted it with a count of 10 or new-build-type or something it can be contracted lazily written out as:
(1245;10):name
--1
--|--2
--|--3,4,15,(60;3),35

and so on or something like that then that would be named as whatever it needed to be named and then it can be given an index number i guess or special-case-name maybe call it 1245P or something

and this is how i mostly want to be able to do things is as lazily as possible:
c234,c34,2,g45,g4,45,h,4j.4hbn,4,b4,b4,b45,b4,5b,45,4,b54,4,b,45b,42,b,54b4,b,4bh,rfg,bet,b6,b,6b,467 and that would make something eventually
this plus using other symbols and groups under parentheses, i just dont have the time to think about it, but would denote how the system works and behaves based on its priorities and builds.

so if we already know what we make can be written out in someway as to this ultimately, we can break it up piece by piece too, and just mix all those pieces in some way to a string of random-interpreated numbers/letters indexed  to themselves being the new version of whatever it was originally built as. This is a way to be super lazy and just randomize something until it works in some way or by some part.
Then excerpt the parts that work with other parts to see what i can build without having to actually look anymore at everything all at once.
its just way way easier to make a massive-variable effort in this way than to actually scrutinize what all 100k some odd lines and 2 or so million or more words i typed out really meant AND OR WHETHER OR NOT ITS JUST PLAIN VIRAL.

This may lead to some BROKEN-ENDS  fairly quickly but might work at some point so I really just don't care.
All I need to nkow it that it works somewhat based off the documentation of the overall project to be able to tell

There is also a very quick way to do this.
Is to set every word in the document to its spacing, a brand new line, remove all its duplicte words, and keep only unique words, given each line an index number, and just use the index numbers as they are to represent everything covered in the document, sure some don't work and some repeat themselves, but what do I care, just throw it together until something craps out. This doesnt really work though because I typo'ed alot of things, so of course there might be repititions, but I don't care and I am that lazy.
IMO its way easier than coding it together, by formulating all that into a build, and expecting the one way you do it to work, there should be many chances that it would work in other ways/arranged.
There may be some roadblocks per-sae but it will eventually find parts and bits that work really well maybe even better than what I had intended them for but I don't want to spend the brainpower figuring it out anymore.
There is also another way: and that is to convert EVERY WORD into its own value and just turn the fatfile/document into a translated version of that and hope it just builds properly through trial and error, it can more or less fix or overwrite itself to however it would, in a perfect world with excellent ai, this might be possible. For me though, nothing is possible anymore because everything is out of my ability to even test.

The way I have said above, with the tiny little pyramids of their directories splayed out, is a good start.
That by some mixture of each build co-operatively symlinking to each other it can be possible, there might be some wasted paths/data entries but its not big deal.
And also Its really just a tiny bunch of triangulated-pathways until it all works (probably even down the the ultimated end-points, that they do so)---so I guess a little extra space is not a big deal, because its JUST A LITTLE EXTRA SPACE that doesnt really matter.
I might estimate there are only about 3600 triangulated-components in this way, and maybe at most 36,000 or so, to really have to sort through, and TBH that can be done in a day just to see everything (not typically to understand it all, but to actually just put it away in a box on a shelf is something easier to think about)
Now to begin to understand of it is like trying to decipher a kaeleidoscope of information and all its tiny patterns and ways it makes itself logical in some way.
--
Further more we would have a triangle that might have an endpoint to each string of it such that it translates to a corrective meta for when it is in expression of being under protocol/policy for which may influence/denote its reposnsive behavoirs at all as well.
And that is why I kind of stop caring as to making it all a single-instance build, because the meta involved might just overcomplicate things and changeout other details anyways, that at the end for every code-string involved in this directory-assistance, a meta-protocol would be applied.
so that would also look slightly different too in the setup being something like:



MAIN(+meta-exact/stat-value)
--SUBSYSTEM(+meta-exact/stat-value)
--|--MODULES(+meta-exact/stat-value)
--|--|--SUBMODULES(+meta-exact/stat-value)
--|--|--|--CHAPTER(+meta-exact/stat-value)
--|--|--|--|--META(+meta-exact/stat-value)
Count:/1-5/6-10/(+meta-exact/stat-value)
--|--|--|--|--|--CHAIN(+meta-exact/stat-value)
--|--|--|--|--|--|--CHUNK(+meta-exact/stat-value)
--|--|--|--|--|--|--|--FLUX(+meta-exact/stat-value)
--|--|--|--|--|--|--|--|--SecurityLevel(+meta-exact/stat-value)
--|--|--|--|--|--|--|--|--|--ARRAY(+meta-exact/stat-value)

or you know...some absolute bullshit as to how the whole block/sector of this data would be interpreted per line
and is more like a massive-hybrid/encrypted token that is under constant change of itself as well so even now its even more dumb


MAIN(+meta-exact/stat-value)!!(TOKEN-STEP)
--SUBSYSTEM(+meta-exact/stat-value)!!(TOKEN-STEP)
--|--MODULES(+meta-exact/stat-value)!!(TOKEN-STEP)
--|--|--SUBMODULES(+meta-exact/stat-value)!!(TOKEN-STEP)
--|--|--|--CHAPTER(+meta-exact/stat-value)!!(TOKEN-STEP)
--|--|--|--|--META(+meta-exact/stat-value)!!(TOKEN-STEP)
Count:/1-5/6-10/(+meta-exact/stat-value)!!(TOKEN-STEP)
--|--|--|--|--|--CHAIN(+meta-exact/stat-value)!!(TOKEN-STEP)
--|--|--|--|--|--|--CHUNK(+meta-exact/stat-value)!!(TOKEN-STEP)
--|--|--|--|--|--|--|--FLUX(+meta-exact/stat-value)!!(TOKEN-STEP)
--|--|--|--|--|--|--|--|--SecurityLevel(+meta-exact/stat-value)!!(TOKEN-STEP)
--|--|--|--|--|--|--|--|--|--ARRAY(+meta-exact/stat-value)!!(TOKEN-STEP)

with !! being any other bullshit that would occur inbetween the synchronizations taking place. So yeah, impossible for me to even explain right.
but what it means is that END2END encryptions will mostly be matched as correctly as possible despite each of the components having extreme varaibles in their nature to synth/commit and (THIS ENSURES ALSO that not only the data would be matched but also there would be no loss or constraint/conflict that is made an issue of "retaining said data over its expression")---and also it takes a little bit longer to compute the more complicated something is and to me this is "stupidly complicated" but thats how it is i guess.
And why? Because maybe one split-second the wifi basically goes woosh and wipes everything into nothingness.
And I am hesitant to say it but maybe its because of cluster-approximation in routing or floating lamps as to being so sensitive as to why this occurs. I DONT KNOW, I am just plain sorry I don't know enough to really know.
But let's for a second take a pause and try to set this up for LAMPS/SIMBITS to incorporate this supposedly EASE-OF-ACCESS thing we are making for "FAST-TRACKING" a build by random.

That we add the idea of what it might be in front of it all:
(DUMBLAMP-1 with MAYBE SIMBITS or SOME WIFI PROBLEM):

(DUMBLAMP-1)MAIN(+meta-exact/stat-value)!!(TOKEN-STEP)
(DUMBLAMP-1)--SUBSYSTEM(+meta-exact/stat-value)!!(TOKEN-STEP)
(DUMBLAMP-1)--|--MODULES(+meta-exact/stat-value)!!(TOKEN-STEP)
(DUMBLAMP-1)--|--|--SUBMODULES(+meta-exact/stat-value)!!(TOKEN-STEP)
(DUMBLAMP-1)--|--|--|--CHAPTER(+meta-exact/stat-value)!!(TOKEN-STEP)
(DUMBLAMP-1)--|--|--|--|--META(+meta-exact/stat-value)!!(TOKEN-STEP)
(DUMBLAMP-1)Count:/1-5/6-10/(+meta-exact/stat-value)!!(TOKEN-STEP)
(DUMBLAMP-1)--|--|--|--|--|--CHAIN(+meta-exact/stat-value)!!(TOKEN-STEP)
(DUMBLAMP-1)--|--|--|--|--|--|--CHUNK(+meta-exact/stat-value)!!(TOKEN-STEP)
(DUMBLAMP-1)--|--|--|--|--|--|--|--FLUX(+meta-exact/stat-value)!!(TOKEN-STEP)
(DUMBLAMP-1)--|--|--|--|--|--|--|--|--SecurityLevel(+meta-exact/stat-value)!!(TOKEN-STEP)
(DUMBLAMP-1)--|--|--|--|--|--|--|--|--|--ARRAY(+meta-exact/stat-value)!!(TOKEN-STEP)

so that 
(DUMBLAMP-1)=(DUMBLAMP-1) regardless of WIFI-PROBLEM/SIMBIT-USAGE

And maybe that makes things better/easier (but really I don't think it does help much at all except to do things this way and make it only that the system ever corrects itself to rely complicitly on this way of doing things anyway)--which is not always good, but if you have to crack it all open it at least makes it so you won't accidentally screw up everything. I think? I dunno.
So now we need to build the SYSTEM/SERVER/SERVOS/LANGUAGE to make that all make sense, which is easy to do, its just that I am still not sure if it works the way I want it to, but its easier said than done so I am JUST SAYING IT.
---
THE OTHER PART is that it goes completely corrupt and needs to be restructured anyway.
THIS IS WHAT HIS WHOLE TEMPLATELAYOUT IS SUPPOSED TO DO, and if it doesnt do that, well then, at least we tried, because if it all goes COMPLETELY CORRUPT UPON A TEMPLATELAYOUT, well at least we have a TEMPLATELAYOUT that maybe would be worth trying to recover at all. Whereas, we would just have absolute-garbage and would only be able to datamosh it/salvage it as nothing it used to be.
The recovery process still is not without flaws/faults and would probably lose alot of data, but it would still give some DEFINITION as to what it was before it all went corrupt, IF THE TEMPLATELAYOUT (or some idea like it is incorporated for this use specifically)---so that is why I justify using this dumb-idea at all.
