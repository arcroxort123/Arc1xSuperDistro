6/29/2024

This is to ATTEMPT to illustrate a build based off the documentation and all its assets in some way.
I am trying to make it look like it has a structure.
I am trying to make sure it has selections where necessary. 
I am trying to make sure these selections can be profiled/macro's and other pre-builds/templates. 
I am trying to make sure these depths/layers can hybrid with others as necessary.

Here is a 10-DEEP Layer. I just decided to type together IDK if it makes sense but it simulates the first couple of parse-structures too with some other buzzwords.
The TEMPLATE:

MAIN
--SUBSYSTEM
--|--MODULES
--|--|--SUBMODULES
--|--|--|--CHAPTER
--|--|--|--|--META
Count:/1-5/6-10/
--|--|--|--|--|--CHAIN
--|--|--|--|--|--|--CHUNK
--|--|--|--|--|--|--|--FLUX
--|--|--|--|--|--|--|--|--SecurityLevel
--|--|--|--|--|--|--|--|--|--ARRAY


Here is what it would look like if it was more detailed and specific to what each part does or tries to service:
The EXAMPLE: 

AUXILLIARY
--REFINERY
--|--REACTOR
--|--|--GAMESPACE
--|--|--|--DYNAMO
--|--|--|--|--MARKET
Count:/1-5/6-10/
--|--|--|--|--|--Recursory
--|--|--|--|--|--|--Factory
--|--|--|--|--|--|--|--Dynamic/Static/Random/As-IS
--|--|--|--|--|--|--|--|--(Strong)
--|--|--|--|--|--|--|--|--|--(Power)/Data/Light/Source/Heat/Waste/Water/Fuel/Crypto/(idk)


----So that's there, now we can go down through out module lists/index/registery of all things we suggest build or build together as or in some way correalate/conjugate to a more advanced thing if possible.
But let's assume we have like 1-2000 parts.
So we can be lazy and replace the words with numbers.

0:name
--1
--|--2
--|--|--3
--|--|--|--4
--|--|--|--|--5
Count:/1-5/6-10/
--|--|--|--|--|--6 or 6b
--|--|--|--|--|--|--7
--|--|--|--|--|--|--|--8a(8b)(8c)(8d)
--|--|--|--|--|--|--|--|--(9;30)
--|--|--|--|--|--|--|--|--|--10  or 11 and 12 or 13

Each module might hav a number/letter corresponsind a different name under its index. It may also be represented in a count of how many modules are at that buildpoint or something to the effect of what to use with what else or together, or to keep out of.
I don't have a code for this and I am too tired to see if it makes sense, the point is this is a lazy way to do things but maybe makes more efficient prep-work for codes to work.

So now we could have like---a major build work with other major builds and program them to work in order to their priorities under request by appearence or something.
1,13,17,3,2,299,133,120,1560,150,200:name 

And that would typically be something with many other things working as a uniform/product based of whatever it is. And whatever it makes comes out as whatever it is.
1245:product

So if you wanted 1245 and you wanted it with a count of 10 or new-build-type or something it can be contracted lazily written out as:
(1245;10):name
--1
--|--2
--|--3,4,15,(60;3),35

and so on or something like that then that would be named as whatever it needed to be named and then it can be given an index number i guess or special-case-name maybe call it 1245P or something

and this is how i mostly want to be able to do things is as lazily as possible:
c234,c34,2,g45,g4,45,h,4j.4hbn,4,b4,b4,b45,b4,5b,45,4,b54,4,b,45b,42,b,54b4,b,4bh,rfg,bet,b6,b,6b,467 and that would make something eventually
this plus using other symbols and groups under parentheses, i just dont have the time to think about it, but would denote how the system works and behaves based on its priorities and builds.

so if we already know what we make can be written out in someway as to this ultimately, we can break it up piece by piece too, and just mix all those pieces in some way to a string of random-interpreated numbers/letters indexed  to themselves being the new version of whatever it was originally built as. This is a way to be super lazy and just randomize something until it works in some way or by some part.
Then excerpt the parts that work with other parts to see what i can build without having to actually look anymore at everything all at once.
its just way way easier to make a massive-variable effort in this way than to actually scrutinize what all 100k some odd lines and 2 or so million or more words i typed out really meant.

This may lead to some BROKEN-ENDS  fairly quickly but might work at some point so I really just don't care.
All I need to nkow it that it works somewhat based off the documentation of the overall project to be able to tell

There is also a very quick way to do this.
Is to set every word in the document to its spacing, a brand new line, remove all its duplicte words, and keep only unique words, given each line an index number, and just use the index numbers as they are to represent everything covered in the document, sure some don't work and some repeat themselves, but what do I care, just throw it together until something craps out. This doesnt really work though because I typo'ed alot of things, so of course there might be repititions, but I don't care and I am that lazy.
IMO its way easier than coding it together, by formulating all that into a build, and expecting the one way you do it to work, there should be many chances that it would work in other ways/arranged.
There may be some roadblocks per-sae but it will eventually find parts and bits that work really well maybe even better than what I had intended them for but I don't want to spend the brainpower figuring it out anymore.
There is also another way: and that is to convert EVERY WORD into its own value and just turn the fatfile/document into a translated version of that and hope it just builds properly through trial and error, it can more or less fix or overwrite itself to however it would, in a perfect world with excellent ai, this might be possible. For me though, nothing is possible anymore because everything is out of my ability to even test.

The way I have said above, with the tiny little pyramids of their directories splayed out, is a good start.
That by some mixture of each build co-operatively symlinking to each other it can be possible, there might be some wasted paths/data entries but its not big deal.
And also Its really just a tiny bunch of triangulated-pathways until it all works (probably even down the the ultimated end-points, that they do so)---so I guess a little extra space is not a big deal, because its JUST A LITTLE EXTRA SPACE that doesnt really matter.
I might estimate there are only about 3600 triangulated-components in this way, and maybe at most 36,000 or so, to really have to sort through, and TBH that can be done in a day just to see everything (not typically to understand it all, but to actually just put it away in a box on a shelf is something easier to think about)
Now to begin to understand of it is like trying to decipher a kaeleidoscope of information and all its tiny patterns and ways it makes itself logical in some way.
