This is typical of how I would deduce a computation. This is a simple situation at first in which grubworks occur.
THIS MIGHT BE MISINFORMATION BUT I CAN MAKE IT WORK, AND I AM A DUMBASS, so uh, take that as you will.
LETS GET READY TO BOOF SOME ASS-CODE 
its for counter-surfaces so i can SAY WHATEVA I WANT

Applied-CounterSurface Part1
We have our initial signal which is killed off like a beep.
We have a second signal sequence which lasts longer slightly.
We have our third signal sequence which helps to switch from a bit of the initial to a secondary position of the beep-boop (boot sign). (which recognizes a space for which a beep could occur and skips over it, forming an unwritten or unmentioned-switched)--or just as well(it does the switch then and then because of its signal basis)
--
We permute these and abstract these to big/medium/small signals in which beep big/small/medium and big/small/medium boop  translate to various switches, and kills, of their pending beeps and boops in sequences.
6 or so total. We call it the abc and 123's of grubworks. Idk...i do anyway.
Because of this bs, we can keep a signal going when it otherwise would be killed.

We do this a bunch more with what works, what doesnt, what does work when it doesnt, what doesnt work when it does, etc. Whats working when it doesnt and making it look like its working or not etc when it isnt or is etc.
This is the typical killswitch signal mainframe to help to establish layers of signals within sequence of themselves and define a code-length. The codelength makes it so it can be used to define when and how or for how much space something is.
We use this code-length to establish a network of code-signals relative to themselves and form a code table. 1 is a single length/2 is a double length/ 3 a triple length/ 4 a quadrapel length (totaling at least 10 lengths for a table maybe more or less so depending on descripancy)--its basically a byte-template.

With the code table we form a basic fstab, knowing that it is the right way we want, we call it the fstab in which we simulate the grubworks in a code-length signaled as a partition of space.
With fstab one we have essentially defined grubworks under a signal itself and code length corresponding, we know that the fstab is there
We continue this technique of killswitch signal mainframes to establish layers of fstabs and build a dev1. (and the system is more or less able to retain its code-length and assigned grubworks as various fstabs under the assigned spaces and partition)
(The Fstab is a sequence of beeps and boops we know work, we then REVISIT ones that don't and fix them using the ones we know that work and make those more or less work, despite being a little more dirtier and rename them to dirty-signals)--we later clean these up but not now, we don't have the tools to do that per sae (unless we are skipping way ahead into G/Hboot remakes)

Such that we have made sequences of fstabs, we will call these DEV-spaces. The generic sequence for the first DevSpace is 1-FSTAB-Sequence. (The following are used for multiple sequences to definte ABC's and 123's and symbols AlphaNumerics by VALUE by also GUESSING the space required for them so it helps to leave out/ADD IN some room marginal errors)
With the input for DEV1 we apply, and create Dev2, which is based off the first dev1 and having been signaled to be apart from dev1 on its own space, we can also define Dev3 under the code table of dev1's fstabs and dev2's fstabs as the Dev3's fstabs for which represent the system table having been defined/alloted specific fstab-spacing in its partitions.
Now with those system tables in play we can begin the killswitch signal mainframes for those layers of dev-spaces with their assigned corresponding fstabs generating a system-table, a keymap of system-table variants, and an applied header for each system-table-variant expressed in keymaps and assigned code-lengths in the partition of that devspace (being finalized in dev3)
We finish out with the system table being marked as ext4 having assigned the keymap and codelength for that to occur as, and in that partition we replicate as a backup for in its usage (just because i dont want to go through it again when it gets corrupt) and another for using the backup within having already been built with some added codespace as is sensible to it being the FINAL-system-partition (of which is additive)

It's actually not ext4 but some other weird thing that might as well be that...sources just trust me bro (i dunno what to call it but its something)---UNFORTUNATELY, we have to convert this CRAP as it leaves alot of descripancy in the code-lengths of their assigned mappings, but generally its a good start to go with. We can't really fix it now so we can ignore it (we can live happily onward ignoring this forever but we shouldn't)
So fun...doing this all the time (i've done it at least 3 times and once even blind)
Now because of the Dev-Partitions we can begin to auto-build those into the correct system-assigned-codespaces being marked as G:/

G:/ actually means G1:/. So G2:/ and G3:/ following in the same killswitch-signal-mainframes and layers, being that g1 consists of the devspace builds, g2 consists of those builds under backup, and g3 consists of the backup with extra spaces.
And furthermore G1 defines the situation being, that since G2 backsup as G1, that follows that G3 is either case and whatever else it wants to be as, or how it wants that information as, and or how that information is when called on, and or how that it looks like when it is used, and how it translated in its use as being, whatever G3 wants that information to be used in the way it is. As to also relay it to others.
This is pretty much the automatic bios for which is set by those headers being built in grubworks. It is abstracted and corrected as well as switched correctedly by the code-tables, and further stablized with the correct fstabs and represented partitions that follow, as the DEV-space is applied (a single devspace can be used for this, but its better to have as much space to pack up it all in a single BIOS)-which can be automatic once its all built to the correct output of a signal and code-length (for which it should be by now)--however that was not easy without the key-maps and headers applied to represent them all with dev2 and dev3.

Now we are at H.
H is freely able to host G and continue interactive processes in which H acts as G, because H has as much space as it wants and is essentially the Hard-Drive. And because of this, we have reached a FULLQUARTER(25 steps) in which this can be safely adjusted if that INTIALIZED-encode/machine-signal/data-space is retained.  (From a savestate, continued-use, or assigned-ram/flash)--all of which the H-series can do)--infact:
INFACT, h can be used as a periphereal to G-being used, and can also later be used as an H-boot such as a flash over of G from a periphereal under the correct assigned-partition builds such as ext4 or btfs or uefi. Infact, this is where we take the H-BOOTs to be used as a Bios and Corresponding Terminal usage to define a ROOT INSTANCE. 
Root Instance is -I (or h2 if you follow)--this is good but it gets better:
and because root instance is not necessarily safe from boot-corruptions, it can be bypassed into USER-J (which is H3) (And now its great!)

The Great Gets even better:
--it later follows that the sequence is actually H0-h1-h2-h3 when using cryptographic implementation. H0 can be referred to as K (which is simple as cryptographically converted USER J) by logging in as USER J under a password. There are better cryptographic systems than just a password which will later be rebuilt into. However, getting the correct format and boot sequence to do so first is important by H1.
Performing the CRYPTOGRAHIC event the sequence becomes H1-H2-H3-H0 with H0 being USER J in cryptographic conversion, and essentially being the K STEP.
This KSTEP symbolizes the Quarter(25) being cryptographically applied. Making up for the next 20 steps in that things get complicated but breakdown as lmnop-qrstu-vwxyz (the next quarter)--im calling it a quarter because the steps get implied-more-heavily and valuate as more than usual as you might see.

it may also be that with vrsims: the quarter can translate a rollback/cryptographic cover of

floppy -> a (G-series)
backup -> b (H-series)(crypto)
======
o -> c (ai-drive)(integrated ai-shell)
p -> d (ai-disk stream)(intergrated ai-workspace)
======
q -> e (ai-disk writer)/shared-user(crypto)/locked
r -> f (shared-writers)/remote-user(crypto)
s -> g (simulated-disk)/ai-rewrites(crypto)
t -> h (simulated-shared-ai-writers(crypto)/unlocked
======
u -> i(ai-network)
v -> j(ai-user)/new-user-crypto
w -> k(fuel based)/(charge based)
x -> l(missing-package/package-filler)(autobuilder)
y -> m(new-ai-workspace)(crypto-currency based)/exclusive-user-access(ai-memetic-based)
z -> n(ai-thread potency availbility)

By now we have fixed and adjusted certain appropriated partitions to be assigned for specific tasks and can later fix and render down the descripancy of their code-signal formatting for a better digitalized-streamline error free signal of data-based memetic code system. Which is incredibly dope to do with AI-integration because I dont have to uh...give two shits.
From HERE, we can just morse our way into any language system including binary and hexadecimal or further create cryptograph BASED-signal numerical-indexing which requires a true-formating or rewrited code-legnths-to-specified-formats anyways.

sources:just trust me bro (almost forgot this crap and there are reasons why)--its complicated and almost stupid. but it works.


ALRIGHT 
Applied CounterSurface Part 2
As above I had described a working or nomimal stable/unstable or otherwise erratic/normal system to some degree FUNCTIONS as intended. Now let me re-explain that in a different way.
In the course of a signal, a short or instant signal can be interpreted, as an instance for which may as well define a consecutive orientation of any account, generally in line of what is NEXT (from nothing). Such that the next thing is in order generally, whatever it is, will be, intepreted as that next thing being whatever it is, even if another signal, the very same. However it is for standard purposing, interpreted that same signals are the same all the time. This can be disputed but for the record of a system as above described, it will be kept as such.
Such THAT, a different signal such as a longer/potent signal may be applied, and intepreted as the other type there of. And is typical of MORSE CODE.
The orientation of that longer signal, might be expresed as yet, a different direction, as maybe the first being right, the longer version being left. Or a mixture of directions for who knows why by sequencing preferences or interpretations, regardless, this falls in line with the same description, that a signal is the way it is in some way, in other ways, maybe not so much.
Such that in a certain or degreeable expectation or timeframe a mixed signal or mixture or combined signal may apply different values/meanings in orientation, and that refers to ABSTRACTIONS being applied and FORMULATED AbSTRACTIONS being applied to CHANGE the original format of a signal for what is expected, to something different based on its combined-resolutions being configured as such.
That a Short signal (S) or long signal (L) might mean there own things in terms of left/right front/back on/off whatever, can be redeveloped into different meaning if applied in terms of SL or LS meaning an abstraction of S or L depending on priorities, and even LL and SS having meanings assigned to their abstractions of (something this/something that) now being (something else aftwards, even maybe something beforehand) depending on how complex you want it to be making SLS LSL their own thingamjig or also "inherent library"
This is basically how the first few paragraphs of PART 1 were conveyed, without abstraction in mind. NOW it can be in mind, it can be with cryptographics making it entirely different, or formatting making it mean something because the system itself inteprets it however it wants or is assigned to read it as. THE FACT IS, while the MACHINE-CODE IS THERE, it isn't always synonymous, even if its the EXACT SAME SIGNAL CONVEYING SOMETHING ELSE.
So THE MACHINE CODE needs to be defined, and for that, there are tools but also that ABSTRACTION of those codes, formulate differently under those definitions, and are up to intepretation. SOMEONE can technicalyl recode the entire WINDOWS-OPERATING-SYSTEM-MACHINE-CODE to effectively be something else entirely, maybe even, a fucking way to open up a hell-portal. TBH...that was already postulated with MICROSOFTWORD BEING A DOOM GAME SIMULATOR and having its own CODE built in to DOOM or some shit. Point remains.
The LIBRARY assignment needs to be perfectly clear, what is going to happen to the MACHINE CODE being interpreted as signals are conveyed, and how that represents to potential viral data or complicated UNEXPECTED-ERRORS and RUNTIME-ISSUES that crash the system, were it otherwise interpreted differently for instance to be a massive KILL COMMAND to critical processes. DISSECTING the ABSTRACTIONS is the FIRST STEP to knowing how certain signals will react under their MACHINE CODE-PHYSX/EXPIRY. 
And in fact, some SAFE REMOVAL of other devices may result in complications of other DEVICES having recieved inteference of their ENCODES being tampered with, even if not directly. This however is generally avoided by each program having their own data-base and libraries assigned by their own PROGRAM FILES etc which operate throughout the OFFICIAL SYSTEM LANGUAGE-SET. This can also be a REGIONAL-LANGUAGE PROBLEM but can also be STREAMLINED to a corrective fix and generally fast-application of slap fixing and patches under corrective settings to prevent a re-occuring problem. Because security knows best I guess.
This is a VERY MISNOMERED LATENT EFFECT of using MACHINE CODE and ELECTRICAL SIGNALS but it quickly BECOMES OBSOLETE AND FORGOTTEN With very few instances where an outbreak of this problem persists, and sometimes it can be devastating to A FILE-TABLE/FORMATTING which is dependent on these baseline signal types, but is GENERALLY FILTERED THROUGH BASIC ABSTRACTION AND LANGUAGE-COMPATIBILITY ETC.
THIS ALSO CAN BE LATER OPTIMIZE TO NEVER EVER BE A PROBLEM, but not always in the EARLY STAGES OF A BASIC OS MACHINE CODE DEVELOPMENTAL STAGE, it can be exploited and DRASTICALLY. Infact, people have done this before this exact thing in hacking, but I simply do not care to get into that aspect right now. I am TRYING TO CORREALATE A SUBSTITUTE EXPLAINATION OF WHAT WAS ORIGINALLY DEMONSTRATED.
---
In that SUCH case of EXAMPLING/I dont have an exmaple SORRY. But if you FOLLOW THAT LINE OF CODE you can begin to MANIPULATE ABSTRACTING A COMMAND LINE INTERACTIVELY, but knowing WHEN TO "knock around" and when not to "knock around" signals to achieve a different definition than intended in order to CONTRIVE some WORKABILITY where otherwise there may be none, this requires alot of trial and error but gets done once it "Hits the NOG" as they say. (obivously im bored and making up sayings)
Here we can assembly some DEGREE of actual linguistics, that may be SUFFIX/PREFIX to yet another signal, and we can see and abstract a complicated manner of (left and rights) etc into being something like prefix/mainword/suffix in which the MAINWORD is HEAVILY influenced and often changed of its resolved/resulting outcomes or even HEAVILY MIXED with other words for which may be synonymous. LSLS-SLSL-LSSL might actually be the same as SLSL-SSLL-LSLL but i didnt do the MATH or have a decent library to make it so. 
(let me make a veryfucked up and crude number joke that could 666=777 or some shit like that)--heh, doom portals are NOT TOYS, ANYWAYS, we essentially are working with a LOWBROW-midgrade-HELLPORTAL that is code-linguistics. And As with synonymous as that may be in different terms, might mean COMPLETELY differently ADVERBLY. It's really just a chance situation, and I really couldn't give a flying neener-neener.
But let's assume we built some form of HBOOT or even a BOOSTRAP prefaced programming such as a bios/diagnostic/installer/code-format such as what I would refer to as a MSFT (or micro-signal-formatted-template)---or some shit, i forgot what I was thinking because i was in a brain-fog. BUT ANYWAYS, Something like that could basically set up a quick FSTAB-situation and make for a virtualized-computation being quickly advanced (less reliably and more of a just trust me dawg type of code-work)
